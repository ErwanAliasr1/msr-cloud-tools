#!/bin/bash
#
# showboost	Show C0 cycle rate (turbo boost). MSR specific (currently Intel)
#
# This was written for use in a Xen guest (AWS EC2).
#
# USAGE: showboost [interval]
#
# This uses the CPU Model Specific Registers to read the turbo boost ratios and
# CPU cycles. The way the MSR is read is processor specific. If you want to run
# this on AMD or other CPU types, the MSR definitions section will need editing.
#
# COPYRIGHT: Copyright (c) 2014 Brendan Gregg.
#
#  This program is free software; you can redistribute it and/or
#  modify it under the terms of the GNU General Public License
#  as published by the Free Software Foundation; either version 2
#  of the License, or (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software Foundation,
#  Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
#
#  (http://www.gnu.org/copyleft/gpl.html)
#
# 12-Sep-2014   Brendan Gregg   Created this.

micro_architecture="undef"

### MSR definitions
IA32_MPERF=0xe7
IA32_APERF=0xe8
MSR_TURBO_RATIO_LIMIT_ONE_CPU=undef
MSR_TURBO_RATIO_LIMIT_ONE_CPU_MASK=undef
MSR_TURBO_RATIO_LIMIT_MAX_CPU=undef
MSR_TURBO_RATIO_LIMIT_MAX_CPU_MASK=undef

### options
cpu=0
interval=5
max_time=0

function usage {
    echo >&2 "USAGE: showboost [-h] [-t interval] [-m <microarch>]"
    echo >&2 ""
    echo >&2 "-h                  : Print this help"
    echo >&2 "-m <microarch>      : Override with the given micro architecture"
    echo >&2 "                      Possible values : ivy_bridge"
    echo >&2 "-t <time>           : Define the interval time (default is $interval)"
    echo >&2 "-T <time>           : Test duration (default is infinite)"
    exit
}

function fatal_error {
    echo >&2 "ERROR: $@"
    exit 1
}

check_env() {
    while getopts ":ht:m:T:" opt; do
        case $opt in
            h)
                usage
            ;;
            t)
                interval=$OPTARG
            ;;
            T)
                max_time=$OPTARG
            ;;

            m)
                micro_architecture=$OPTARG
            ;;
            \?)
                echo "Invalid option: -$OPTARG" >&2
                usage
            ;;
        esac
    done

    if [[ "$USER" != "root" ]]; then
        fatal_error "needs root access. Exiting."
    fi

    if ! grep -q msr_class_cpu_callback /proc/kallsyms; then
        if ! /sbin/modprobe msr; then
            fatal_error "modprobe msr. Missing msr-tools package? Exiting."
        fi
    fi

    if ! which cpuid &>/dev/null; then
        fatal_error "We need cpuid to detect your CPU"
        exit 1
    fi
}

detect_micro_architecture() {
    cpuid -1 | grep "vendor_id" | grep -q "GenuineIntel"
    if [ $? -ne 0 ]; then
        fatal_error "Current tool only works on Intel Processors"
    fi

    if [ "$micro_architecture" == "undef" ]; then
        synth=$(cpuid -1 | grep  "(synth)")
        echo $synth | grep -qi "ivy bridge" && micro_architecture="ivy_bridge"

        if [ "$micro_architecture" = "undef" ]; then
            fatal_error "This micro architecture is not supported"
        fi
    fi
    echo "Using $micro_architecture micro architecture"
}

define_MSRs() {
case $micro_architecture in
    "ivy_bridge")
        MSR_TURBO_RATIO_LIMIT_ONE_CPU=0x1ad
        MSR_TURBO_RATIO_LIMIT_ONE_CPU_MASK=7:0
        MSR_TURBO_RATIO_LIMIT_ALL_CPU=0x1ae
        MSR_TURBO_RATIO_LIMIT_ALL_CPU_MASK=15:8
    ;;
esac
}

############# MAIN ################

check_env $@

detect_micro_architecture

define_MSRs

base_mhz=$(awk '/cpu MHz/ { print $NF; exit }' /proc/cpuinfo)
base_mhz=${base_mhz%.*}
turbo_one=$(rdmsr $MSR_TURBO_RATIO_LIMIT_ONE_CPU -f $MSR_TURBO_RATIO_LIMIT_ONE_CPU_MASK -d 2>/dev/null)
turbo_all=$(rdmsr $MSR_TURBO_RATIO_LIMIT_ALL_CPU -f $MSR_TURBO_RATIO_LIMIT_ALL_CPU_MASK -d 2>/dev/null)
echo "CPU MHz     :" $base_mhz
echo "Turbo MHz   :" $(( turbo_one * 100 )) "(1 active)"
echo "Turbo Ratio :" $(( turbo_one * 100 * 100 / base_mhz ))"% (1 active)"
if [ -n "$turbo_all" ]; then
    echo "Turbo MHz   :" $(( turbo_all * 100 )) "(all active)"
    echo "Turbo Ratio :" $(( turbo_all * 100 * 100 / base_mhz ))"% (all active)"
else
    echo "This model doesn't report all cpu ratio limit"
fi
echo "CPU $cpu summary every $interval seconds..."
echo

printf "%-10s %-12s %-12s %6s %6s %6s\n" "TIME" "C0_MCYC" "C0_ACYC" "UTIL" \
    "RATIO" "MHz"

total_time=0
while :; do
    t=$(printf "%(%H:%M:%S)T" -1)
    m=$(rdmsr -p$cpu $IA32_MPERF -d)
    a=$(rdmsr -p$cpu $IA32_APERF -d)
    (( dm = m - lm ))
    (( da = a - la ))
    (( ratio = 100 * da / dm ))
    (( max_mhz = base_mhz * da / dm ))
    (( util = dm * 100 / (base_mhz * 1000000 * interval) ))
    if (( lm > 0 )); then
        printf "%-10s %-12d %-12d %5d%% %5d%% %6d\n" $t $dm $da $util $ratio $max_mhz
    fi
    lm=$m
    la=$a
    sleep $interval
    total_time=$(( $total_time + $interval ))
        if [ $max_time -gt 0 ]; then
            if [ $total_time -gt $max_time ]; then
                break
            fi
        fi
done
